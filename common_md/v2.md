
````python
from flask import Flask, render_template_string
from flask_sock import Sock
from datetime import datetime, timedelta
import time
import json

app = Flask(__name__)
sock = Sock(app)

HTML_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>TradingView Chart</title>
</head>
<body>
    <div id="chartContainer"></div>
    
    <script src="https://cdn.jsdelivr.net/gh/parth-royale/cdn@main/charting_library/charting_library.standalone.js"></script>
    
    <script>
    const datafeed = {
        onReady: (callback) => {
            setTimeout(() => callback({
                supported_resolutions: ['1', '5', '15', '60', '1D'],
                supports_time: true,
                supports_search: true,
                supports_group_request: false
            }), 0);
        },
        
        resolveSymbol: (symbolName, onResolve, onError) => {
            setTimeout(() => onResolve({
                name: 'MOCK',
                full_name: 'MOCK',
                description: 'Mock Data',
                type: 'crypto',
                session: '24x7',
                exchange: 'MOCK',
                listed_exchange: 'MOCK',
                timezone: 'UTC',
                ticker: 'MOCK',
                minmov: 1,
                pricescale: 100,
                has_intraday: true,
                supported_resolutions: ['1', '5', '15', '60', '1D'],
                has_seconds: true,
                data_status: 'streaming',
                volume_precision: 2,
                pointvalue: 1,
                currency_code: 'USD'
            }), 0);
        },
        
        getBars: (symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) => {
            const { from, to } = periodParams;
            
            fetch(`/historic?from=${from}&to=${to}&resolution=${resolution}`)
                .then(r => r.json())
                .then(data => {
                    const bars = data.map(d => ({
                        time: d.time * 1000,
                        open: d.open,
                        high: d.high,
                        low: d.low,
                        close: d.close,
                        volume: d.volume || 0
                    })).filter(b => b.time >= from * 1000 && b.time <= to * 1000);
                    
                    onHistoryCallback(bars, { noData: bars.length === 0 });
                })
                .catch(err => onErrorCallback('Failed to load historical data'));
        },
        
        subscribeBars: (symbolInfo, resolution, onTick) => {
            const ws = new WebSocket(`ws://${window.location.host}/ws`);
            
            let currentBar = null;
            
            ws.onmessage = event => {
                const tick = JSON.parse(event.data);
                console.log("Incoming Tick:", tick);
                const barTime = Math.floor(tick.timestamp / 60) * 60;
                
                if (!currentBar || barTime > currentBar.time / 1000) {
                    if (currentBar) {
                        onTick({
                            ...currentBar,
                            time: currentBar.time,
                            close: currentBar.close
                        });
                    }
                    currentBar = {
                        time: barTime * 1000,
                        open: tick.value,
                        high: tick.value,
                        low: tick.value,
                        close: tick.value,
                        volume: 0
                    };
                } else {
                    currentBar.high = Math.max(currentBar.high, tick.value);
                    currentBar.low = Math.min(currentBar.low, tick.value);
                    currentBar.close = tick.value;
                }
                
                onTick({
                    ...currentBar,
                    time: currentBar.time
                });
            };
        }
    };

    new TradingView.widget({
        container: 'chartContainer',
        symbol: 'MOCK',
        interval: '1',
        datafeed: datafeed,
        library_path: 'https://cdn.jsdelivr.net/gh/parth-royale/cdn@main/charting_library/',
        locale: 'en',
        theme: 'light',
        fullscreen: true,
        autosize: true
    });
    </script>
</body>
</html>
"""

def generate_mock_ticks(num_rows, start_index=0):
    start_time = datetime(2024, 2, 27, 1, 0, 0)
    tick_value = 100.0
    
    if start_index > 0:
        tick_value = 100.0 * (1.10 ** start_index)
    
    for i in range(start_index, num_rows + start_index):
        yield {
            "timestamp": (start_time + timedelta(seconds=i)).timestamp(),
            "value": tick_value
        }
        tick_value *= 1.10

def create_initial_candles(ticks):
    candles = []
    current_candle = None
    
    for tick in ticks:
        candle_time = tick["timestamp"] - (tick["timestamp"] % 60)
        
        if not current_candle or candle_time > current_candle["time"]:
            if current_candle:
                candles.append(current_candle)
            current_candle = {
                "time": candle_time,
                "open": tick["value"],
                "high": tick["value"],
                "low": tick["value"],
                "close": tick["value"]
            }
        else:
            current_candle["high"] = max(current_candle["high"], tick["value"])
            current_candle["low"] = min(current_candle["low"], tick["value"])
            current_candle["close"] = tick["value"]
    
    if current_candle:
        candles.append(current_candle)
    
    return candles

@app.route("/")
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route("/historic")
def historic_data():
    initial_ticks = list(generate_mock_ticks(600))
    initial_candles = create_initial_candles(initial_ticks)
    return json.dumps(initial_candles)

@sock.route("/ws")
def push_realtime_ticks(ws):
    for tick in generate_mock_ticks(600, start_index=600):
        time.sleep(0.05)
        ws.send(json.dumps({
            "timestamp": tick["timestamp"],
            "value": tick["value"]
        }))

if __name__ == "__main__":
    app.run(debug=True, port=80)
````
